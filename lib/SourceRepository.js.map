{"version":3,"sources":["../src/SourceRepository.js"],"names":["SourceRepository","packageServer","id","version","findPackage","uri","undefined","request","json","result","feed","d","results","fromFeed","keywords","latestOnly","inclusive","op","filter","idterms","words","split","map","word","latest","filterPackages","filterString","feeds","Promise","all"],"mappings":";;;;;;;;AAAA;;;;AAEA;;;;AACA;;;;;;;;;;;;;;IAEqBA,gB;;;AAEnB,4BAAYC,aAAZ,EAA2B;AAAA;;AAAA;;AAEzB,UAAKA,aAAL,GAAqBA,aAArB;AAFyB;AAG1B;;AAED;;;;;;;;;;;4EAMaC,E,EAAIC,O;;;;;iDACR,KAAKC,WAAL,CAAiBF,EAAjB,EAAqBC,OAArB,KAAiC,I;;;;;;;;;;;;;;;;;AAG1C;;;;;;;;;;8EAMkBD,E,EAAIC,O;;;;;;AAChBE,mB,eAAgB,KAAKJ,a,gDAAwDC,E;;AACjF,oBAAIC,YAAYG,SAAhB,EAA2B;AACzBD,oCAAgB,KAAKJ,aAArB,gDAA6EC,EAA7E,sCAAgHC,OAAhH;AACD;;AAED;;uBACmB,eAAKI,OAAL,CAAa;AAC9BF,uBAAKA,GADyB;AAE9BG,wBAAM;AAFwB,iBAAb,C;;;AAAfC,sB;;oBAKCA,M;;;;;kDACI,I;;;AAGLC,oB,GAAOD,OAAOE,CAAP,CAASC,OAAT,CAAiB,CAAjB,C;;uBAEE,qBAAWC,QAAX,CAAoBH,IAApB,C;;;;;;;;;;;;;;;;;;;;AAGf;;;;;;;;;;;8EAOqBI,Q,EAAUC,U,EAAYC,S;;;;;;AACzC,oBAAIF,aAAaR,SAAjB,EAA4BQ,WAAW,EAAX;AAC5B,oBAAIE,cAAcV,SAAlB,EAA6BU,YAAY,IAAZ;AAC7B,oBAAID,eAAeT,SAAnB,EAA8BS,aAAa,IAAb;;AAE1BE,kB,GAAKD,YAAY,KAAZ,GAAoB,I;AACzBE,sB,GAAS,E;AACTC,uB,GAAU,E;AACVC,qB,GAAQN,SAASO,KAAT,CAAe,GAAf,C;;AACZD,sBAAME,GAAN,CAAU,gBAAQ;AAChB,sBAAIH,WAAW,EAAf,EACEA,iBAAeF,EAAf;AACF,sBAAIM,QAAQ,EAAZ,EAAgB;AACdJ,iDAA2BI,IAA3B;AACD;AACF,iBAND;;AAQIC,sB,GAAST,aAAa,MAAb,GAAsB,O;;;AAEnCG,iDAA+BM,MAA/B;;AAEA,oBAAIL,WAAW,EAAf,EAAmB;AACjBD,uCAAmBC,OAAnB;AACD;;;uBAEY,KAAKM,cAAL,CAAoBP,MAApB,C;;;;;;;;;;;;;;;;;;;;AAKf;;;;;;;;;8EAKqBQ,Y;;;;;;;;AACnB,oBAAIA,iBAAiBpB,SAArB,EAAgCoB,eAAe,EAAf;;AAE5BR,sB,gBAAoBQ,Y;AAEpBrB,mB,eAAgB,KAAKJ,a,2BAAmCiB,M;;AAE5D;;;uBACmB,eAAKX,OAAL,CAAa;AAC9BF,uBAAKA,GADyB;AAE9BG,wBAAM;AAFwB,iBAAb,C;;;AAAfC,sB;AAKAkB,qB,GAAQlB,OAAOE,CAAP,CAASC,O;kDACdgB,QAAQC,GAAR,CAAYF,MAAML,GAAN;AAAA,wEAAU,kBAAOZ,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCAAsB,qBAAWG,QAAX,CAAoBH,IAApB,CAAtB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAV;;AAAA;AAAA;AAAA;AAAA,oBAAZ,C;;;;;;;;;;;;;;;;;;;;;kBApGUV,gB","file":"SourceRepository.js","sourcesContent":["import http from \"./sys/http\"\n\nimport PackageRepository from \"./PackageRepository\"\nimport PackageRef from \"./PackageRef\"\n\nexport default class SourceRepository extends PackageRepository {\n\n  constructor(packageServer) {\n    super();\n    this.packageServer = packageServer;\n  }\n\n  /**\n   * Checks if a package exists in the repository\n   * @param {string} id Id of package to find\n   * @param {string} [version] Version of package to find\n   * @return {boolean}\n   */\n  async exists(id, version) {\n    return this.findPackage(id, version) != null;\n  }\n\n  /**\n   * Finds a package in the repository\n   * @param {string} id Id of package to find\n   * @param {string} [version] Version of package to find\n   * @return {PackageRef}\n   */\n  async findPackage(id, version) {\n    let uri = `http://${this.packageServer}/api/v2/Packages()?$filter=Id%20eq%20%27${id}%27%20and%20IsLatestVersion%20eq%20true`;\n    if (version !== undefined) {\n      uri = `http://${this.packageServer}/api/v2/Packages()?$filter=Id%20eq%20%27${id}%27%20and%20Version%20eq%20%27${version}%27`;\n    }\n\n    // call to server\n    let result = await http.request({\n      uri: uri,\n      json: true\n    })\n\n    if (!result) {\n      return null;\n    }\n\n    let feed = result.d.results[0]\n\n    return await PackageRef.fromFeed(feed);\n  }\n\n  /**\n   * Get packages using a keyword search\n   * @param {string} [keywords] Keywords to search for\n   * @param {bool} [latestOnly] Only get latestversions of packages (default=true)\n   * @param {bool} [inclusive] Use and AND search on keywords instead of OR (default=true)\n   * @return {PackageRef[]}\n   */\n  async searchPackages(keywords, latestOnly, inclusive) {\n    if (keywords === undefined) keywords = \"\";\n    if (inclusive === undefined) inclusive = true;\n    if (latestOnly === undefined) latestOnly = true;\n\n    let op = inclusive ? \"and\" : \"or\";\n    let filter = \"\";\n    let idterms = \"\"\n    let words = keywords.split(\" \");\n    words.map(word => {\n      if (idterms != \"\")\n        idterms += ` ${op} `;\n      if (word != \"\") {\n        idterms += `substringof('${word}',Id)`\n      }\n    })\n\n    let latest = latestOnly ? \"true\" : \"false\";\n\n    filter = `IsLatestVersion eq ${latest}`\n\n    if (idterms != \"\") {\n      filter += ` and (${idterms})`\n    }\n\n    return await this.filterPackages(filter);\n\n    let uri = `http://${this.packageServer}/api/v2/Packages()?${filter}`;\n  }\n\n  /**\n   * Get packages using a filter string (odata $filter)\n   * @param {string} filterString Filter string to use\n   * @return {PackageRef[]}\n   */\n  async filterPackages(filterString) {\n    if (filterString === undefined) filterString = \"\";\n\n    let filter = `$filter=${filterString}`\n\n    let uri = `http://${this.packageServer}/api/v2/Packages()?${filter}`;\n\n    // call to server\n    let result = await http.request({\n      uri: uri,\n      json: true\n    })\n\n    let feeds = result.d.results\n    return Promise.all(feeds.map(async (feed) => await PackageRef.fromFeed(feed)));\n  }\n}"]}