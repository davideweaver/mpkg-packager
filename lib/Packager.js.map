{"version":3,"sources":["../src/Packager.js"],"names":["Packager","packageServer","showPrerelease","packageManager","id","version","ignoreDependencies","undefined","ver","console","log","toString","localRepository","findPackage","installedPackage","greaterOrEqualTo","sourceRepository","exists","uninstallPackage","installPackage","error","equalTo","availablePackage","lessOrEqualTo","updatePackage","getLatestVersion","availablePackageVersion","greaterTo","isInstalled","getPackages","keywords","onlyLatest","inclusive","searchPackages","filter","filterPackages"],"mappings":"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","file":"Packager.js","sourcesContent":["import PackageManager from \"./PackageManager\"\nimport SemanticVersion from \"./SemanticVersion\"\n\nexport default class Packager {\n\n  constructor(packageServer) {\n    this.showPrerelease = false;\n    this.packageServer = packageServer;\n    this.packageManager = new PackageManager(packageServer);\n  }\n\n  async installPackage(id, version, ignoreDependencies) {\n    if (ignoreDependencies === undefined)\n      ignoreDependencies = false;\n\n      const ver = version != null ? new SemanticVersion(version) : null;\n      console.log(`installing: package=${id}, version=${ver && ver.toString()}`);\n\n      try {\n\n        let installedPackage = await this.packageManager.localRepository.findPackage(id);\n        if (installedPackage) {\n          console.log(\"- found:\", installedPackage.id, installedPackage.version.toString());\n          if (ver && installedPackage.version.greaterOrEqualTo(ver)) {\n            // If the package is already installed (or the version being installed is lower), then we do not need to do anything. \n            return false;\n          }\n          else if (await this.packageManager.sourceRepository.exists(id, version)) {\n            console.log(\"- removing old:\", installedPackage.id, installedPackage.version.toString());\n            // If the package is already installed, but\n            // (a) the version we require is different from the one that is installed, \n            // (b) side-by-side is disabled\n            // we need to uninstall it.\n            // However, before uninstalling, make sure the package exists in the source repository. \n            await this.packageManager.uninstallPackage(id);\n          }\n        }\n\n        await this.packageManager.installPackage(id, version, ignoreDependencies);\n\n      }\n      catch (e) {\n        console.error(`- could not install: ${id} (${e})`);\n        return false;\n      }\n\n      return true;\n  }\n\n  async uninstallPackage(id, version) {\n\n    const ver = version != null ? new SemanticVersion(version) : null;\n    console.log(`uninstalling: package=${id}, version=${ver && ver.toString()}`);\n\n    try {\n\n      let installedPackage = await this.packageManager.localRepository.findPackage(id);\n      if (installedPackage) {\n        console.log(\"- found:\", installedPackage.id, installedPackage.version.toString());\n        if (ver && !installedPackage.version.equalTo(ver)) {\n          return false;\n        }\n        await this.packageManager.uninstallPackage(id, true, true);\n      }\n    }\n    catch (e) {\n      console.error(`- could not uninstall: ${id} (${e})`);\n      return false;\n    }\n\n    return true;\n  }\n\n  async updatePackage(id, ignoreDependencies) {\n\n    console.log(`updating: package=${id}`);\n\n    try {\n\n      var availablePackage = await this.packageManager.sourceRepository.findPackage(id);\n      if (availablePackage == null) {\n        console.log(`- package ${id} was not found`);\n        return false;\n      }\n\t\t\t\t\n      var installedPackage = await this.packageManager.localRepository.findPackage(id);\n      if (installedPackage != null) {\n        console.log(\"- found:\", installedPackage.id, installedPackage.version.toString());\n        if (availablePackage.version.lessOrEqualTo(installedPackage.version))\n        {\n          console.log(`- package ${availablePackage.version.toString()} is the latest version`);\n          return true;\n        }\n      }\n\t\t\t\t\n      if (!installedPackage)\n      {\n        await this.packageManager.installPackage(id, availablePackage.version.toString(), ignoreDependencies, this.showPrerelease);\n      }\n      else\n      {\n        await this.packageManager.updatePackage(id, !ignoreDependencies, this.showPrerelease);\n      }\n    }\n    catch (e) {\n      console.error(`- could not update: ${id} (${e})`);\n      return false;\n    }\n\n    return true;\n  }\n\n  async isUpdateAvailable(id, version) {\n\n    let ver = version != null ? new SemanticVersion(version) : null;\n\n    try {\n\n      if (ver == null) {\n        let installedPackage = await this.packageManager.localRepository.findPackage(id);\n        if (installedPackage) {\n          console.log(\"- found:\", installedPackage.id, installedPackage.version.toString());\n          ver = installedPackage.version;\t\n        }\n        else {\n          console.log(`- not found: ${installedPackage.id}`);\n          return false;\n        }\n      }\n\n      var availablePackageVersion = new SemanticVersion(await this.getLatestVersion(id));\n      if (availablePackageVersion.greaterTo(ver)) {\n        return true;\n      }\n    }\n    catch (e) {\n      console.error(`- could not query availability: ${id} (${e})`);\n      return false;\n    }\n\n    return false;\n  }\n\n  async isInstalled(id, version) {\n\n    try {\n      return await this.packageManager.isInstalled(id, version);\n    }\n    catch (e) {\n      console.error(`could not find '${id}' (${e})`);\n    }\n\n    return false;\n  }\n\n  async getInstalledPackage(id) {\n\n    try {\n      return await this.packageManager.localRepository.findPackage(id);\n    }\n    catch (e) {\n      console.error(`error getting installed package '${id}' (${e})`);\n    }\n  }\n\n  async getInstalledPackages() {\n\n    try {\n      return await this.packageManager.localRepository.getPackages();\n    }\n    catch (e) {\n      console.error(`error getting installed packages (${e})`);\n    }\n  }\n\n  /**\n   * Get the version of the latest package\n   * @param {string} id id of package to query\n   * @return {string} version of latest package or null\n   */\n  async getLatestVersion(id) {\n    try {\n      var availablePackage = await this.packageManager.sourceRepository.findPackage(id);\n      if (availablePackage)\n      {\n        return availablePackage.version.toString();\n      }\n    }\n    catch (e) {\n      console.error(`could not query '${id}' version (${e})`);\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets packages from server using a keyword search\n   * @param {string} keywords keywords to search package ids\n   * @param {bool} onlyLatest get only latest versions of matching packages\n   * @param {bool} inclusive search using AND instead of OR for multiple keywords\n   * @return {PackageRef[]}\n   */\n  async getAvailablePackagesByKeywords(keywords, onlyLatest, inclusive) {\n    try {\n      return await this.packageManager.sourceRepository.searchPackages(keywords, onlyLatest, inclusive)\n    }\n    catch (e) {\n      console.error(`could not query '${keywords}' (${e})`);\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets packages from server using an ODATA $filter string\n   * @param {string} filter ODATA $filter string\n   * @return {PackageRef[]}\n   */\n  async getAvailablePackagesByFilter(filter) {\n    try {\n      return await this.packageManager.sourceRepository.filterPackages(filter)\n    }\n    catch (e) {\n      console.error(`could not filter '${filter}' (${e})`);\n    }\n\n    return null;\n  }\n\n}"]}