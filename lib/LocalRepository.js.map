{"version":3,"sources":["../src/LocalRepository.js"],"names":["LocalRepository","localPackagesPath","id","version","findPackage","read","mspec","fromMspec","pkg","undefined","equalTo","base","pkgs","getFiles","folders","Promise","all","map","f","push"],"mappings":";;;;;;;;AAAA;;;;AACA;;;;AAEA;;;;AACA;;;;AACA;;;;;;;;;;;;;;IAEqBA,e;;;AAEnB,2BAAYC,iBAAZ,EAA+B;AAAA;;AAAA;;AAE7B,UAAKA,iBAAL,GAAyBA,iBAAzB;AAF6B;AAG9B;;AAED;;;;;;;;;;;4EAMaC,E,EAAIC,O;;;;;iDACR,KAAKC,WAAL,CAAiBF,EAAjB,EAAqBC,OAArB,KAAiC,I;;;;;;;;;;;;;;;;;AAG1C;;;;;;;;;;8EAMkBD,E,EAAIC,O;;;;;;;;uBAGA,gBAAME,IAAN,CAAc,KAAKJ,iBAAnB,SAAwCC,EAAxC,SAA8CA,EAA9C,Y;;;AAAdI,qB;;uBACY,qBAAWC,SAAX,CAAqBD,KAArB,C;;;AAAZE,mB;;sBAGAL,YAAYM,S;;;;;oBACTD,IAAIL,OAAJ,CAAYO,OAAZ,CAAoB,8BAAoBP,OAApB,CAApB,C;;;;;kDACI,K;;;kDAEJK,G;;;;;kDAGA,I;;;;;;;;;;;;;;;;;AAIX;;;;;;;;;;;;;;;;AAKMG,oB,GAAO,I;AACPC,oB,GAAO,E;;uBACS,gBAAMC,QAAN,CAAe,KAAKZ,iBAApB,C;;;AAAhBa,uB;;uBACEC,QAAQC,GAAR,CAAYF,QAAQG,GAAR;AAAA,wEAAY,kBAAMC,CAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCACZ,OAAKd,WAAL,CAAiBc,CAAjB,CADY;;AAAA;AACxBV,+BADwB;;AAE5B,gCAAIA,GAAJ,EACEI,KAAKO,IAAL,CAAUX,GAAV;;AAH0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAZ;;AAAA;AAAA;AAAA;AAAA,oBAAZ,C;;;kDAKCI,I;;;;;;;;;;;;;;;;;;;;;kBAtDUZ,e","file":"LocalRepository.js","sourcesContent":["import files from \"./sys/files\"\nimport xml from \"./sys/xml\"\n\nimport PackageRepository from \"./PackageRepository\"\nimport PackageRef from \"./PackageRef\"\nimport SemanticVersion from \"./SemanticVersion\"\n\nexport default class LocalRepository extends PackageRepository {\n\n  constructor(localPackagesPath) {\n    super();\n    this.localPackagesPath = localPackagesPath;\n  }\n\n  /**\n   * Checks if a package exists in the repository\n   * @param {string} id Id of package to find\n   * @param {string} [version] Version of package to find\n   * @return {boolean}\n   */\n  async exists(id, version) {\n    return this.findPackage(id, version) != null;\n  }\n\n  /**\n   * Finds a package in the repository\n   * @param {string} id Id of package to find\n   * @param {string} [version] Version of package to find\n   * @return {PackageRef}\n   */\n  async findPackage(id, version) {\n    try {\n      // find the mspec\n      let mspec = await files.read(`${this.localPackagesPath}/${id}/${id}.mspec`);\n      let pkg = await PackageRef.fromMspec(mspec);\n\n      // if we're looking for a specific version, check it\n      if (version !== undefined) {\n        if (!pkg.version.equalTo(new SemanticVersion(version)))\n          return false;\n      }\n      return pkg;\n    }\n    catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Get packages in the repository\n   * @return {PackageRef[]}\n   */\n  async getPackages() {\n    let base = this;\n    let pkgs = [];\n    let folders = await files.getFiles(this.localPackagesPath);\n    await Promise.all(folders.map(async f => {\n      let pkg = await this.findPackage(f);\n      if (pkg)\n        pkgs.push(pkg);\n    }));\n    return pkgs;\n  }\n\n}"]}